import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  BigInt: { input: any; output: any; }
  ISO8601DateTime: { input: any; output: any; }
};

/** Autogenerated input type of Auth */
export type AuthInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  companyName: Scalars['String']['input'];
};

/** Autogenerated return type of Auth. */
export type AuthPayload = {
  __typename?: 'AuthPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  company?: Maybe<Company>;
  errors: Array<Scalars['String']['output']>;
};

export type CapTable = {
  __typename?: 'CapTable';
  shareholders: Array<CapTableShareholder>;
  sharesExcludingOptions: Scalars['Int']['output'];
  sharesExcludingOptionsPercentage: Scalars['Float']['output'];
  totalShares: Scalars['Int']['output'];
  totalSharesPercentage: Scalars['Float']['output'];
  unallocatedOptions: Scalars['Int']['output'];
  unallocatedOptionsPercentage: Scalars['Float']['output'];
};

export type CapTableShareholder = {
  __typename?: 'CapTableShareholder';
  fullyDilutedPercentage?: Maybe<Scalars['Float']['output']>;
  fullyDilutedTotal?: Maybe<Scalars['Int']['output']>;
  name: Scalars['String']['output'];
};

export type Company = {
  __typename?: 'Company';
  capTable: CapTable;
  conversionResults: Array<ConversionResult>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  financialInstruments: Array<FinancialInstrument>;
  fullyDilutedShares?: Maybe<Scalars['Int']['output']>;
  fullyDilutedSubtotalPercentage?: Maybe<Scalars['Float']['output']>;
  fullyDilutedTotal?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  nextRound: NextRound;
  outstandingOptions?: Maybe<Scalars['Int']['output']>;
  shareholderFullyDiluted?: Maybe<Scalars['Int']['output']>;
  shareholders: Array<Shareholder>;
  unallocatedOptions: Scalars['Int']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  users: Array<User>;
};

export type ConversionResult = {
  __typename?: 'ConversionResult';
  conversionPrice: Scalars['Float']['output'];
  discountedSharePrice: Scalars['Float']['output'];
  holderId: Scalars['ID']['output'];
  holderName: Scalars['String']['output'];
  instrumentType: Scalars['String']['output'];
  sharesConverted: Scalars['BigInt']['output'];
  valuationCapDenominator: Scalars['BigInt']['output'];
  valuationCapSharePrice: Scalars['Float']['output'];
};

/** Autogenerated input type of CreateCompany */
export type CreateCompanyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** Autogenerated input type of CreateFinancialInstrument */
export type CreateFinancialInstrumentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  companyId: Scalars['Int']['input'];
  conversionDate?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  discountRate?: InputMaybe<Scalars['Float']['input']>;
  instrumentType: Scalars['String']['input'];
  interestRate?: InputMaybe<Scalars['Float']['input']>;
  issueDate?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  name: Scalars['String']['input'];
  principal: Scalars['Int']['input'];
  valuationCap: Scalars['Int']['input'];
};

/** Autogenerated input type of CreateInvestor */
export type CreateInvestorInput = {
  amount: Scalars['Int']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  companyId: Scalars['Int']['input'];
  name: Scalars['String']['input'];
};

/** Autogenerated input type of CreateShareholder */
export type CreateShareholderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  companyId: Scalars['Int']['input'];
  dilutedShares: Scalars['Int']['input'];
  name: Scalars['String']['input'];
  outstandingOptions: Scalars['Int']['input'];
};

/** Autogenerated input type of CreateUser */
export type CreateUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  companyId: Scalars['Int']['input'];
  email: Scalars['String']['input'];
};

/** Autogenerated input type of DeleteFinancialInstrument */
export type DeleteFinancialInstrumentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  financialInstrumentId: Scalars['Int']['input'];
};

/** Autogenerated input type of DeleteInvestor */
export type DeleteInvestorInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** Autogenerated input type of DeleteShareholder */
export type DeleteShareholderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  shareholderId: Scalars['Int']['input'];
};

export type FinancialInstrument = {
  __typename?: 'FinancialInstrument';
  accruedInterest?: Maybe<Scalars['Int']['output']>;
  companyId: Scalars['Int']['output'];
  conversionDate?: Maybe<Scalars['ISO8601DateTime']['output']>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  discountRate?: Maybe<Scalars['Float']['output']>;
  id: Scalars['ID']['output'];
  instrumentType: Scalars['String']['output'];
  interestRate?: Maybe<Scalars['Float']['output']>;
  issueDate?: Maybe<Scalars['ISO8601DateTime']['output']>;
  name: Scalars['String']['output'];
  principal: Scalars['Int']['output'];
  principalAndInterest?: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  valuationCap: Scalars['Int']['output'];
};

export type Investor = {
  __typename?: 'Investor';
  amount: Scalars['Int']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type Mutation = {
  __typename?: 'Mutation';
  auth?: Maybe<AuthPayload>;
  createCompany?: Maybe<Company>;
  createFinancialInstrument?: Maybe<FinancialInstrument>;
  createInvestor?: Maybe<Investor>;
  createShareholder?: Maybe<Shareholder>;
  createUser?: Maybe<User>;
  deleteFinancialInstrument?: Maybe<Company>;
  deleteInvestor?: Maybe<Investor>;
  deleteShareholder?: Maybe<Company>;
  updateCompany?: Maybe<Company>;
  updateFinancialInstrument?: Maybe<FinancialInstrument>;
  updateInvestor?: Maybe<Investor>;
  updateNextRound?: Maybe<NextRound>;
  updateShareholder?: Maybe<Shareholder>;
};


export type MutationAuthArgs = {
  input: AuthInput;
};


export type MutationCreateCompanyArgs = {
  input: CreateCompanyInput;
};


export type MutationCreateFinancialInstrumentArgs = {
  input: CreateFinancialInstrumentInput;
};


export type MutationCreateInvestorArgs = {
  input: CreateInvestorInput;
};


export type MutationCreateShareholderArgs = {
  input: CreateShareholderInput;
};


export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


export type MutationDeleteFinancialInstrumentArgs = {
  input: DeleteFinancialInstrumentInput;
};


export type MutationDeleteInvestorArgs = {
  input: DeleteInvestorInput;
};


export type MutationDeleteShareholderArgs = {
  input: DeleteShareholderInput;
};


export type MutationUpdateCompanyArgs = {
  input: UpdateCompanyInput;
};


export type MutationUpdateFinancialInstrumentArgs = {
  input: UpdateFinancialInstrumentInput;
};


export type MutationUpdateInvestorArgs = {
  input: UpdateInvestorInput;
};


export type MutationUpdateNextRoundArgs = {
  input: UpdateNextRoundInput;
};


export type MutationUpdateShareholderArgs = {
  input: UpdateShareholderInput;
};

export type NextRound = {
  __typename?: 'NextRound';
  buyingPower?: Maybe<Scalars['BigInt']['output']>;
  companyId: Scalars['Int']['output'];
  implicitValuation?: Maybe<Scalars['BigInt']['output']>;
  investors?: Maybe<Array<Investor>>;
  preMoneyValuation?: Maybe<Scalars['BigInt']['output']>;
  roundSize?: Maybe<Scalars['BigInt']['output']>;
};

export type Query = {
  __typename?: 'Query';
  companies: Array<Company>;
  company: Company;
  users: Array<User>;
};


export type QueryCompanyArgs = {
  id: Scalars['ID']['input'];
};

export type Shareholder = {
  __typename?: 'Shareholder';
  companyId: Scalars['Int']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  dilutedShares?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  outstandingOptions?: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Autogenerated input type of UpdateCompany */
export type UpdateCompanyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  companyId: Scalars['Int']['input'];
  name: Scalars['String']['input'];
  unallocatedOptions?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of UpdateFinancialInstrument */
export type UpdateFinancialInstrumentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  companyId: Scalars['Int']['input'];
  conversionDate?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  discountRate?: InputMaybe<Scalars['Float']['input']>;
  financialInstrumentId: Scalars['Int']['input'];
  instrumentType: Scalars['String']['input'];
  interestRate?: InputMaybe<Scalars['Float']['input']>;
  issueDate?: InputMaybe<Scalars['ISO8601DateTime']['input']>;
  name: Scalars['String']['input'];
  principal?: InputMaybe<Scalars['Int']['input']>;
  valuationCap?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of UpdateInvestor */
export type UpdateInvestorInput = {
  amount: Scalars['Int']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  name: Scalars['String']['input'];
};

/** Autogenerated input type of UpdateNextRound */
export type UpdateNextRoundInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  companyId: Scalars['Int']['input'];
  preMoneyValuation: Scalars['Int']['input'];
  roundSize: Scalars['Int']['input'];
};

/** Autogenerated input type of UpdateShareholder */
export type UpdateShareholderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  companyId: Scalars['Int']['input'];
  dilutedShares: Scalars['Int']['input'];
  name: Scalars['String']['input'];
  outstandingOptions: Scalars['Int']['input'];
  shareholderId: Scalars['Int']['input'];
};

export type User = {
  __typename?: 'User';
  company: Company;
  companyId: Scalars['Int']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  email: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type CreateShareholderMutationVariables = Exact<{
  input: CreateShareholderInput;
}>;


export type CreateShareholderMutation = { __typename?: 'Mutation', createShareholder?: { __typename?: 'Shareholder', id: string, name: string } | null };

export type UpdateShareholderMutationVariables = Exact<{
  input: UpdateShareholderInput;
}>;


export type UpdateShareholderMutation = { __typename?: 'Mutation', updateShareholder?: { __typename?: 'Shareholder', id: string, name: string } | null };

export type DeleteShareholderMutationVariables = Exact<{
  input: DeleteShareholderInput;
}>;


export type DeleteShareholderMutation = { __typename?: 'Mutation', deleteShareholder?: { __typename?: 'Company', id: string } | null };

export type UpdateCompanyMutationVariables = Exact<{
  input: UpdateCompanyInput;
}>;


export type UpdateCompanyMutation = { __typename?: 'Mutation', updateCompany?: { __typename?: 'Company', id: string, name: string, unallocatedOptions: number } | null };

export type CreateFinancialInstrumentMutationVariables = Exact<{
  input: CreateFinancialInstrumentInput;
}>;


export type CreateFinancialInstrumentMutation = { __typename?: 'Mutation', createFinancialInstrument?: { __typename?: 'FinancialInstrument', id: string, name: string } | null };

export type UpdateFinancialInstrumentMutationVariables = Exact<{
  input: UpdateFinancialInstrumentInput;
}>;


export type UpdateFinancialInstrumentMutation = { __typename?: 'Mutation', updateFinancialInstrument?: { __typename?: 'FinancialInstrument', id: string, name: string } | null };

export type DeleteFinancialInstrumentMutationVariables = Exact<{
  input: DeleteFinancialInstrumentInput;
}>;


export type DeleteFinancialInstrumentMutation = { __typename?: 'Mutation', deleteFinancialInstrument?: { __typename?: 'Company', id: string } | null };

export type UpdateNextRoundMutationVariables = Exact<{
  input: UpdateNextRoundInput;
}>;


export type UpdateNextRoundMutation = { __typename?: 'Mutation', updateNextRound?: { __typename?: 'NextRound', companyId: number } | null };

export type CreateInvestorMutationVariables = Exact<{
  input: CreateInvestorInput;
}>;


export type CreateInvestorMutation = { __typename?: 'Mutation', createInvestor?: { __typename?: 'Investor', id: string, name: string, amount: number } | null };

export type UpdateInvestorMutationVariables = Exact<{
  input: UpdateInvestorInput;
}>;


export type UpdateInvestorMutation = { __typename?: 'Mutation', updateInvestor?: { __typename?: 'Investor', id: string, name: string, amount: number } | null };

export type DeleteInvestorMutationVariables = Exact<{
  input: DeleteInvestorInput;
}>;


export type DeleteInvestorMutation = { __typename?: 'Mutation', deleteInvestor?: { __typename?: 'Investor', id: string } | null };

export type AuthMutationVariables = Exact<{
  input: AuthInput;
}>;


export type AuthMutation = { __typename?: 'Mutation', auth?: { __typename?: 'AuthPayload', errors: Array<string>, company?: { __typename?: 'Company', id: string, name: string, unallocatedOptions: number, fullyDilutedShares?: number | null, outstandingOptions?: number | null, shareholderFullyDiluted?: number | null, fullyDilutedSubtotalPercentage?: number | null, fullyDilutedTotal?: number | null, createdAt: any, updatedAt: any, users: Array<{ __typename?: 'User', id: string, email: string, createdAt: any, updatedAt: any, company: { __typename?: 'Company', id: string } }>, financialInstruments: Array<{ __typename?: 'FinancialInstrument', id: string, name: string, instrumentType: string, principal: number, interestRate?: number | null, valuationCap: number, discountRate?: number | null, conversionDate?: any | null, issueDate?: any | null, principalAndInterest?: number | null, accruedInterest?: number | null }>, nextRound: { __typename?: 'NextRound', companyId: number, preMoneyValuation?: any | null, roundSize?: any | null, buyingPower?: any | null, implicitValuation?: any | null, investors?: Array<{ __typename?: 'Investor', id: string, name: string, amount: number }> | null }, conversionResults: Array<{ __typename?: 'ConversionResult', conversionPrice: number, discountedSharePrice: number, holderId: string, holderName: string, instrumentType: string, sharesConverted: any, valuationCapDenominator: any, valuationCapSharePrice: number }>, shareholders: Array<{ __typename?: 'Shareholder', id: string, name: string, dilutedShares?: number | null, outstandingOptions?: number | null, createdAt: any, updatedAt: any, companyId: number }>, capTable: { __typename?: 'CapTable', sharesExcludingOptions: number, sharesExcludingOptionsPercentage: number, unallocatedOptions: number, unallocatedOptionsPercentage: number, totalShares: number, totalSharesPercentage: number, shareholders: Array<{ __typename?: 'CapTableShareholder', name: string, fullyDilutedTotal?: number | null, fullyDilutedPercentage?: number | null }> } } | null } | null };

export type UsersQueryVariables = Exact<{ [key: string]: never; }>;


export type UsersQuery = { __typename?: 'Query', users: Array<{ __typename?: 'User', email: string, company: { __typename?: 'Company', id: string } }> };

export type CompaniesQueryVariables = Exact<{ [key: string]: never; }>;


export type CompaniesQuery = { __typename?: 'Query', companies: Array<{ __typename?: 'Company', id: string, name: string, users: Array<{ __typename?: 'User', id: string }>, shareholders: Array<{ __typename?: 'Shareholder', id: string, name: string }> }> };

export type CompanyQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type CompanyQuery = { __typename?: 'Query', company: { __typename?: 'Company', id: string, name: string, unallocatedOptions: number, fullyDilutedShares?: number | null, outstandingOptions?: number | null, shareholderFullyDiluted?: number | null, fullyDilutedSubtotalPercentage?: number | null, fullyDilutedTotal?: number | null, createdAt: any, updatedAt: any, users: Array<{ __typename?: 'User', id: string, email: string, createdAt: any, updatedAt: any, company: { __typename?: 'Company', id: string } }>, financialInstruments: Array<{ __typename?: 'FinancialInstrument', id: string, name: string, instrumentType: string, principal: number, interestRate?: number | null, valuationCap: number, discountRate?: number | null, conversionDate?: any | null, issueDate?: any | null, principalAndInterest?: number | null, accruedInterest?: number | null }>, nextRound: { __typename?: 'NextRound', companyId: number, preMoneyValuation?: any | null, roundSize?: any | null, buyingPower?: any | null, implicitValuation?: any | null, investors?: Array<{ __typename?: 'Investor', id: string, name: string, amount: number }> | null }, conversionResults: Array<{ __typename?: 'ConversionResult', conversionPrice: number, discountedSharePrice: number, holderId: string, holderName: string, instrumentType: string, sharesConverted: any, valuationCapDenominator: any, valuationCapSharePrice: number }>, shareholders: Array<{ __typename?: 'Shareholder', id: string, name: string, dilutedShares?: number | null, outstandingOptions?: number | null, createdAt: any, updatedAt: any, companyId: number }>, capTable: { __typename?: 'CapTable', sharesExcludingOptions: number, sharesExcludingOptionsPercentage: number, unallocatedOptions: number, unallocatedOptionsPercentage: number, totalShares: number, totalSharesPercentage: number, shareholders: Array<{ __typename?: 'CapTableShareholder', name: string, fullyDilutedTotal?: number | null, fullyDilutedPercentage?: number | null }> } } };


export const CreateShareholderDocument = gql`
    mutation CreateShareholder($input: CreateShareholderInput!) {
  createShareholder(input: $input) {
    id
    name
  }
}
    `;
export type CreateShareholderMutationFn = Apollo.MutationFunction<CreateShareholderMutation, CreateShareholderMutationVariables>;

/**
 * __useCreateShareholderMutation__
 *
 * To run a mutation, you first call `useCreateShareholderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateShareholderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createShareholderMutation, { data, loading, error }] = useCreateShareholderMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateShareholderMutation(baseOptions?: Apollo.MutationHookOptions<CreateShareholderMutation, CreateShareholderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateShareholderMutation, CreateShareholderMutationVariables>(CreateShareholderDocument, options);
      }
export type CreateShareholderMutationHookResult = ReturnType<typeof useCreateShareholderMutation>;
export type CreateShareholderMutationResult = Apollo.MutationResult<CreateShareholderMutation>;
export type CreateShareholderMutationOptions = Apollo.BaseMutationOptions<CreateShareholderMutation, CreateShareholderMutationVariables>;
export const UpdateShareholderDocument = gql`
    mutation UpdateShareholder($input: UpdateShareholderInput!) {
  updateShareholder(input: $input) {
    id
    name
  }
}
    `;
export type UpdateShareholderMutationFn = Apollo.MutationFunction<UpdateShareholderMutation, UpdateShareholderMutationVariables>;

/**
 * __useUpdateShareholderMutation__
 *
 * To run a mutation, you first call `useUpdateShareholderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateShareholderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateShareholderMutation, { data, loading, error }] = useUpdateShareholderMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateShareholderMutation(baseOptions?: Apollo.MutationHookOptions<UpdateShareholderMutation, UpdateShareholderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateShareholderMutation, UpdateShareholderMutationVariables>(UpdateShareholderDocument, options);
      }
export type UpdateShareholderMutationHookResult = ReturnType<typeof useUpdateShareholderMutation>;
export type UpdateShareholderMutationResult = Apollo.MutationResult<UpdateShareholderMutation>;
export type UpdateShareholderMutationOptions = Apollo.BaseMutationOptions<UpdateShareholderMutation, UpdateShareholderMutationVariables>;
export const DeleteShareholderDocument = gql`
    mutation DeleteShareholder($input: DeleteShareholderInput!) {
  deleteShareholder(input: $input) {
    id
  }
}
    `;
export type DeleteShareholderMutationFn = Apollo.MutationFunction<DeleteShareholderMutation, DeleteShareholderMutationVariables>;

/**
 * __useDeleteShareholderMutation__
 *
 * To run a mutation, you first call `useDeleteShareholderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteShareholderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteShareholderMutation, { data, loading, error }] = useDeleteShareholderMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteShareholderMutation(baseOptions?: Apollo.MutationHookOptions<DeleteShareholderMutation, DeleteShareholderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteShareholderMutation, DeleteShareholderMutationVariables>(DeleteShareholderDocument, options);
      }
export type DeleteShareholderMutationHookResult = ReturnType<typeof useDeleteShareholderMutation>;
export type DeleteShareholderMutationResult = Apollo.MutationResult<DeleteShareholderMutation>;
export type DeleteShareholderMutationOptions = Apollo.BaseMutationOptions<DeleteShareholderMutation, DeleteShareholderMutationVariables>;
export const UpdateCompanyDocument = gql`
    mutation UpdateCompany($input: UpdateCompanyInput!) {
  updateCompany(input: $input) {
    id
    name
    unallocatedOptions
  }
}
    `;
export type UpdateCompanyMutationFn = Apollo.MutationFunction<UpdateCompanyMutation, UpdateCompanyMutationVariables>;

/**
 * __useUpdateCompanyMutation__
 *
 * To run a mutation, you first call `useUpdateCompanyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCompanyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCompanyMutation, { data, loading, error }] = useUpdateCompanyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCompanyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCompanyMutation, UpdateCompanyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCompanyMutation, UpdateCompanyMutationVariables>(UpdateCompanyDocument, options);
      }
export type UpdateCompanyMutationHookResult = ReturnType<typeof useUpdateCompanyMutation>;
export type UpdateCompanyMutationResult = Apollo.MutationResult<UpdateCompanyMutation>;
export type UpdateCompanyMutationOptions = Apollo.BaseMutationOptions<UpdateCompanyMutation, UpdateCompanyMutationVariables>;
export const CreateFinancialInstrumentDocument = gql`
    mutation CreateFinancialInstrument($input: CreateFinancialInstrumentInput!) {
  createFinancialInstrument(input: $input) {
    id
    name
  }
}
    `;
export type CreateFinancialInstrumentMutationFn = Apollo.MutationFunction<CreateFinancialInstrumentMutation, CreateFinancialInstrumentMutationVariables>;

/**
 * __useCreateFinancialInstrumentMutation__
 *
 * To run a mutation, you first call `useCreateFinancialInstrumentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateFinancialInstrumentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createFinancialInstrumentMutation, { data, loading, error }] = useCreateFinancialInstrumentMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateFinancialInstrumentMutation(baseOptions?: Apollo.MutationHookOptions<CreateFinancialInstrumentMutation, CreateFinancialInstrumentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateFinancialInstrumentMutation, CreateFinancialInstrumentMutationVariables>(CreateFinancialInstrumentDocument, options);
      }
export type CreateFinancialInstrumentMutationHookResult = ReturnType<typeof useCreateFinancialInstrumentMutation>;
export type CreateFinancialInstrumentMutationResult = Apollo.MutationResult<CreateFinancialInstrumentMutation>;
export type CreateFinancialInstrumentMutationOptions = Apollo.BaseMutationOptions<CreateFinancialInstrumentMutation, CreateFinancialInstrumentMutationVariables>;
export const UpdateFinancialInstrumentDocument = gql`
    mutation UpdateFinancialInstrument($input: UpdateFinancialInstrumentInput!) {
  updateFinancialInstrument(input: $input) {
    id
    name
  }
}
    `;
export type UpdateFinancialInstrumentMutationFn = Apollo.MutationFunction<UpdateFinancialInstrumentMutation, UpdateFinancialInstrumentMutationVariables>;

/**
 * __useUpdateFinancialInstrumentMutation__
 *
 * To run a mutation, you first call `useUpdateFinancialInstrumentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateFinancialInstrumentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateFinancialInstrumentMutation, { data, loading, error }] = useUpdateFinancialInstrumentMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateFinancialInstrumentMutation(baseOptions?: Apollo.MutationHookOptions<UpdateFinancialInstrumentMutation, UpdateFinancialInstrumentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateFinancialInstrumentMutation, UpdateFinancialInstrumentMutationVariables>(UpdateFinancialInstrumentDocument, options);
      }
export type UpdateFinancialInstrumentMutationHookResult = ReturnType<typeof useUpdateFinancialInstrumentMutation>;
export type UpdateFinancialInstrumentMutationResult = Apollo.MutationResult<UpdateFinancialInstrumentMutation>;
export type UpdateFinancialInstrumentMutationOptions = Apollo.BaseMutationOptions<UpdateFinancialInstrumentMutation, UpdateFinancialInstrumentMutationVariables>;
export const DeleteFinancialInstrumentDocument = gql`
    mutation DeleteFinancialInstrument($input: DeleteFinancialInstrumentInput!) {
  deleteFinancialInstrument(input: $input) {
    id
  }
}
    `;
export type DeleteFinancialInstrumentMutationFn = Apollo.MutationFunction<DeleteFinancialInstrumentMutation, DeleteFinancialInstrumentMutationVariables>;

/**
 * __useDeleteFinancialInstrumentMutation__
 *
 * To run a mutation, you first call `useDeleteFinancialInstrumentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteFinancialInstrumentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteFinancialInstrumentMutation, { data, loading, error }] = useDeleteFinancialInstrumentMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteFinancialInstrumentMutation(baseOptions?: Apollo.MutationHookOptions<DeleteFinancialInstrumentMutation, DeleteFinancialInstrumentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteFinancialInstrumentMutation, DeleteFinancialInstrumentMutationVariables>(DeleteFinancialInstrumentDocument, options);
      }
export type DeleteFinancialInstrumentMutationHookResult = ReturnType<typeof useDeleteFinancialInstrumentMutation>;
export type DeleteFinancialInstrumentMutationResult = Apollo.MutationResult<DeleteFinancialInstrumentMutation>;
export type DeleteFinancialInstrumentMutationOptions = Apollo.BaseMutationOptions<DeleteFinancialInstrumentMutation, DeleteFinancialInstrumentMutationVariables>;
export const UpdateNextRoundDocument = gql`
    mutation UpdateNextRound($input: UpdateNextRoundInput!) {
  updateNextRound(input: $input) {
    companyId
  }
}
    `;
export type UpdateNextRoundMutationFn = Apollo.MutationFunction<UpdateNextRoundMutation, UpdateNextRoundMutationVariables>;

/**
 * __useUpdateNextRoundMutation__
 *
 * To run a mutation, you first call `useUpdateNextRoundMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateNextRoundMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateNextRoundMutation, { data, loading, error }] = useUpdateNextRoundMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateNextRoundMutation(baseOptions?: Apollo.MutationHookOptions<UpdateNextRoundMutation, UpdateNextRoundMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateNextRoundMutation, UpdateNextRoundMutationVariables>(UpdateNextRoundDocument, options);
      }
export type UpdateNextRoundMutationHookResult = ReturnType<typeof useUpdateNextRoundMutation>;
export type UpdateNextRoundMutationResult = Apollo.MutationResult<UpdateNextRoundMutation>;
export type UpdateNextRoundMutationOptions = Apollo.BaseMutationOptions<UpdateNextRoundMutation, UpdateNextRoundMutationVariables>;
export const CreateInvestorDocument = gql`
    mutation CreateInvestor($input: CreateInvestorInput!) {
  createInvestor(input: $input) {
    id
    name
    amount
  }
}
    `;
export type CreateInvestorMutationFn = Apollo.MutationFunction<CreateInvestorMutation, CreateInvestorMutationVariables>;

/**
 * __useCreateInvestorMutation__
 *
 * To run a mutation, you first call `useCreateInvestorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateInvestorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createInvestorMutation, { data, loading, error }] = useCreateInvestorMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateInvestorMutation(baseOptions?: Apollo.MutationHookOptions<CreateInvestorMutation, CreateInvestorMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateInvestorMutation, CreateInvestorMutationVariables>(CreateInvestorDocument, options);
      }
export type CreateInvestorMutationHookResult = ReturnType<typeof useCreateInvestorMutation>;
export type CreateInvestorMutationResult = Apollo.MutationResult<CreateInvestorMutation>;
export type CreateInvestorMutationOptions = Apollo.BaseMutationOptions<CreateInvestorMutation, CreateInvestorMutationVariables>;
export const UpdateInvestorDocument = gql`
    mutation UpdateInvestor($input: UpdateInvestorInput!) {
  updateInvestor(input: $input) {
    id
    name
    amount
  }
}
    `;
export type UpdateInvestorMutationFn = Apollo.MutationFunction<UpdateInvestorMutation, UpdateInvestorMutationVariables>;

/**
 * __useUpdateInvestorMutation__
 *
 * To run a mutation, you first call `useUpdateInvestorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateInvestorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateInvestorMutation, { data, loading, error }] = useUpdateInvestorMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateInvestorMutation(baseOptions?: Apollo.MutationHookOptions<UpdateInvestorMutation, UpdateInvestorMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateInvestorMutation, UpdateInvestorMutationVariables>(UpdateInvestorDocument, options);
      }
export type UpdateInvestorMutationHookResult = ReturnType<typeof useUpdateInvestorMutation>;
export type UpdateInvestorMutationResult = Apollo.MutationResult<UpdateInvestorMutation>;
export type UpdateInvestorMutationOptions = Apollo.BaseMutationOptions<UpdateInvestorMutation, UpdateInvestorMutationVariables>;
export const DeleteInvestorDocument = gql`
    mutation DeleteInvestor($input: DeleteInvestorInput!) {
  deleteInvestor(input: $input) {
    id
  }
}
    `;
export type DeleteInvestorMutationFn = Apollo.MutationFunction<DeleteInvestorMutation, DeleteInvestorMutationVariables>;

/**
 * __useDeleteInvestorMutation__
 *
 * To run a mutation, you first call `useDeleteInvestorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteInvestorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteInvestorMutation, { data, loading, error }] = useDeleteInvestorMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteInvestorMutation(baseOptions?: Apollo.MutationHookOptions<DeleteInvestorMutation, DeleteInvestorMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteInvestorMutation, DeleteInvestorMutationVariables>(DeleteInvestorDocument, options);
      }
export type DeleteInvestorMutationHookResult = ReturnType<typeof useDeleteInvestorMutation>;
export type DeleteInvestorMutationResult = Apollo.MutationResult<DeleteInvestorMutation>;
export type DeleteInvestorMutationOptions = Apollo.BaseMutationOptions<DeleteInvestorMutation, DeleteInvestorMutationVariables>;
export const AuthDocument = gql`
    mutation Auth($input: AuthInput!) {
  auth(input: $input) {
    company {
      id
      name
      unallocatedOptions
      fullyDilutedShares
      outstandingOptions
      shareholderFullyDiluted
      fullyDilutedSubtotalPercentage
      fullyDilutedTotal
      users {
        id
        email
        company {
          id
        }
        createdAt
        updatedAt
      }
      financialInstruments {
        id
        name
        instrumentType
        principal
        interestRate
        valuationCap
        discountRate
        conversionDate
        issueDate
        principalAndInterest
        accruedInterest
      }
      nextRound {
        companyId
        preMoneyValuation
        roundSize
        buyingPower
        implicitValuation
        investors {
          id
          name
          amount
        }
      }
      conversionResults {
        conversionPrice
        discountedSharePrice
        holderId
        holderName
        instrumentType
        sharesConverted
        valuationCapDenominator
        valuationCapSharePrice
      }
      shareholders {
        id
        name
        dilutedShares
        outstandingOptions
        createdAt
        updatedAt
        companyId
      }
      capTable {
        sharesExcludingOptions
        sharesExcludingOptionsPercentage
        shareholders {
          name
          fullyDilutedTotal
          fullyDilutedPercentage
        }
        unallocatedOptions
        unallocatedOptionsPercentage
        totalShares
        totalSharesPercentage
      }
      createdAt
      updatedAt
    }
    errors
  }
}
    `;
export type AuthMutationFn = Apollo.MutationFunction<AuthMutation, AuthMutationVariables>;

/**
 * __useAuthMutation__
 *
 * To run a mutation, you first call `useAuthMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAuthMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [authMutation, { data, loading, error }] = useAuthMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAuthMutation(baseOptions?: Apollo.MutationHookOptions<AuthMutation, AuthMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AuthMutation, AuthMutationVariables>(AuthDocument, options);
      }
export type AuthMutationHookResult = ReturnType<typeof useAuthMutation>;
export type AuthMutationResult = Apollo.MutationResult<AuthMutation>;
export type AuthMutationOptions = Apollo.BaseMutationOptions<AuthMutation, AuthMutationVariables>;
export const UsersDocument = gql`
    query users {
  users {
    company {
      id
    }
    email
  }
}
    `;

/**
 * __useUsersQuery__
 *
 * To run a query within a React component, call `useUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUsersQuery({
 *   variables: {
 *   },
 * });
 */
export function useUsersQuery(baseOptions?: Apollo.QueryHookOptions<UsersQuery, UsersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
      }
export function useUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UsersQuery, UsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
        }
export function useUsersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<UsersQuery, UsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
        }
export type UsersQueryHookResult = ReturnType<typeof useUsersQuery>;
export type UsersLazyQueryHookResult = ReturnType<typeof useUsersLazyQuery>;
export type UsersSuspenseQueryHookResult = ReturnType<typeof useUsersSuspenseQuery>;
export type UsersQueryResult = Apollo.QueryResult<UsersQuery, UsersQueryVariables>;
export const CompaniesDocument = gql`
    query companies {
  companies {
    id
    name
    users {
      id
    }
    shareholders {
      id
      name
    }
  }
}
    `;

/**
 * __useCompaniesQuery__
 *
 * To run a query within a React component, call `useCompaniesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCompaniesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCompaniesQuery({
 *   variables: {
 *   },
 * });
 */
export function useCompaniesQuery(baseOptions?: Apollo.QueryHookOptions<CompaniesQuery, CompaniesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CompaniesQuery, CompaniesQueryVariables>(CompaniesDocument, options);
      }
export function useCompaniesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CompaniesQuery, CompaniesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CompaniesQuery, CompaniesQueryVariables>(CompaniesDocument, options);
        }
export function useCompaniesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CompaniesQuery, CompaniesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CompaniesQuery, CompaniesQueryVariables>(CompaniesDocument, options);
        }
export type CompaniesQueryHookResult = ReturnType<typeof useCompaniesQuery>;
export type CompaniesLazyQueryHookResult = ReturnType<typeof useCompaniesLazyQuery>;
export type CompaniesSuspenseQueryHookResult = ReturnType<typeof useCompaniesSuspenseQuery>;
export type CompaniesQueryResult = Apollo.QueryResult<CompaniesQuery, CompaniesQueryVariables>;
export const CompanyDocument = gql`
    query company($id: ID!) {
  company(id: $id) {
    id
    name
    unallocatedOptions
    fullyDilutedShares
    outstandingOptions
    shareholderFullyDiluted
    fullyDilutedSubtotalPercentage
    fullyDilutedTotal
    users {
      id
      email
      company {
        id
      }
      createdAt
      updatedAt
    }
    financialInstruments {
      id
      name
      instrumentType
      principal
      interestRate
      valuationCap
      discountRate
      conversionDate
      issueDate
      principalAndInterest
      accruedInterest
    }
    nextRound {
      companyId
      preMoneyValuation
      roundSize
      buyingPower
      implicitValuation
      investors {
        id
        name
        amount
      }
    }
    conversionResults {
      conversionPrice
      discountedSharePrice
      holderId
      holderName
      instrumentType
      sharesConverted
      valuationCapDenominator
      valuationCapSharePrice
    }
    shareholders {
      id
      name
      dilutedShares
      outstandingOptions
      createdAt
      updatedAt
      companyId
    }
    capTable {
      sharesExcludingOptions
      sharesExcludingOptionsPercentage
      shareholders {
        name
        fullyDilutedTotal
        fullyDilutedPercentage
      }
      unallocatedOptions
      unallocatedOptionsPercentage
      totalShares
      totalSharesPercentage
    }
    createdAt
    updatedAt
  }
}
    `;

/**
 * __useCompanyQuery__
 *
 * To run a query within a React component, call `useCompanyQuery` and pass it any options that fit your needs.
 * When your component renders, `useCompanyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCompanyQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useCompanyQuery(baseOptions: Apollo.QueryHookOptions<CompanyQuery, CompanyQueryVariables> & ({ variables: CompanyQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CompanyQuery, CompanyQueryVariables>(CompanyDocument, options);
      }
export function useCompanyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CompanyQuery, CompanyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CompanyQuery, CompanyQueryVariables>(CompanyDocument, options);
        }
export function useCompanySuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CompanyQuery, CompanyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CompanyQuery, CompanyQueryVariables>(CompanyDocument, options);
        }
export type CompanyQueryHookResult = ReturnType<typeof useCompanyQuery>;
export type CompanyLazyQueryHookResult = ReturnType<typeof useCompanyLazyQuery>;
export type CompanySuspenseQueryHookResult = ReturnType<typeof useCompanySuspenseQuery>;
export type CompanyQueryResult = Apollo.QueryResult<CompanyQuery, CompanyQueryVariables>;